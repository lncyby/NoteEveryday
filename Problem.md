# 编写简单锚点
### 锚点是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍。
###### 使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置。
###### 创建到命名锚记的链接的过程分为两步。首先，创建命名锚记，然后创建到该命名锚记的链接。

# 浏览器地址栏中输入url后发生了什么？
### 输入地址
  1.浏览器查找域名的ＩＰ地址  
  2.这一步包括DNS具体的查找过程，包括：浏览器缓存->系统缓存->路由器缓存  
  3.浏览器向web服务器发送一个HTTP请求  
  4.服务器的永久重定向响应（从http://example.com到http://www.example.com）  
  5.浏览器跟踪重定向地址  
  6.服务器处理请求  
  7.服务器返回一个HTTP响应  
  8.浏览器显示HTML  
  9.浏览器发送请求获取嵌入在HTML中的资源（如图片，音频，视频，ＣＳＳ，ＪＳ等等）  
  10.浏览器发送异常请求  
  
# 正确描述CSS优先级的算法
### 行内样式　> id > class > 标签 > 继承 > 浏览器的默认属性
  优先级计算方法：  
  id = 100 class = 10  tag = 1  
  出现一次标签 tag, tag + 1  
  出现一次class  , class + 1  
  出现一次id , id + 1  
  比如： 优先级 = id class tag = 000;  
  #id .f  p {xxxxx:xxx;}, 此时优先级的值 = 111  

# 什么是语义化？语义化的手段都有哪些？
### 语义化就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。strong,em用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。关于语义（Semantics）和默认样式的区别，默认样式是浏览器设定的一些常用tag的表现形式
### 优点：：语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。
语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。

# 块元素？行内元素？
### 块元素:
每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。
常见的块元素有h1~h6、p、div、ul、ol、l等，其中div标记是最典型的块元素。
### 行内元素:
不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。
常见的行内元素有strong、b、em、i、del、s、ins、u、a、span等，其中span标记最典型的行内元素。

# 要能正确的描述清除浮动的几种方式  
  1.采用一个HTML标签，以及css的clear属性，来手工清理浮动；   
  2.采用伪类:after，动态建立一个块元素，设定 clear 属性，清理之前的浮动元素；     
  3.采用CSS overflow 非 visible 值(overflow:auto/overflow:hidden)设定使父容器包含浮动元素；    
  4.采用display:table/display:table-cell 等table系列属性将父元素变成 table 形式自动包含浮动元素；   
  5.使用 TABLE 以及 TD 标签作为浮动元素容器；    
  6.采用 float:left/float:right 方式将父元素同样浮动，就可以包含浮动内容；   
  7.在 IE 6/7 的标准文档模式中设置 “width/height/zoom” 等样式来自动清理浮动。  
  
### 建议使用
  1.采用一个HTML标签，以及css的clear属性，来手工清理浮动;    
  2.为元素设置 overflow:hidden 或 overflow:auto 值，配合可以设置 zoom:1 样式触发 IE6 haslayout 特性，来达到兼容所有浏览器清理浮动的目的   
  3.采用伪元素:after，配合可以设置 zoom:1 样式触发 IE6/7 haslayout 特性，来达到兼容所有浏览器清理浮动的目的.      

# 能正确描述浮动？
### 浮动概念
元素的浮动是指设置了浮动属性的元素会脱离标准文档流的控制，移动到其父元素中指定位置的过程
### 浮动的特点
  1.浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动 。     
  2.浮动的元素A排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶   部会和上一个元素的底部对齐。   
  3.一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。  
  4.浮动根据元素书写的位置来显示相应的浮动。  
  5.元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少。  
  6.如果一个div没有设置高，这个div中的所有的元素都浮动了，那么这个div的高是0。  

# 能正确描述定位？
### 定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。可以迅速的完成其他方式难以实现的效果。
###### 常用定位的属性值：
  1.static, 默认情况下浏览器中所有的盒子都是静态的。  
  2.relative, 相对定位，元素相对于自身位置的移动。  
  3.absolute, 绝对定位,有三种情况。  
    1)如果盒子没有父盒子，那么在绝对定位的时候这个位置是相对于body的。  
    2)如果盒子有父盒子，但是父盒子没有设置定位，那么在绝对定位的时候这个位置还是相对于body的。  
    3)如果盒子有父盒子(祖先盒子)并且父盒子有定位，那么这个时候我们的盒子定位是相对于父盒子的。  
  4.fixed, 固定，以窗口页面进行定位，不会随着滚动条移动。  

# 正确区分定位中哪些值会导致元素脱离标准流???

# 需要正确描述line-height的各种设置方式的优缺点
#### 优点：适用于所有浏览器,无足够空间时不会被截断
#### 缺点：只对文本有效(块级元素无效),多行时，断词比较糟糕,这个方法在小元素上非常有用，例如使按钮文本或者单行文本居中。

# 正确描述变量声明提升以及函数声明提升
##### 变量声明提升： 通过 var 声明的变量在代码执行之前被js引擎提升到了当前作用域的顶部。+
##### 函数声明提升： 通过函数声明的方式（非函数表达式）声明的函数在代码执行之前被js引擎提升到了当前作用域的顶部，而且函数声明提升优先于变量声明提升。
### 声明变量提升：
通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理　（JS在运行前其实有一个编译过程的这个问题，在编译阶段，JS引擎做了一些事使得代码并不是完全一行一行的执行了，而是将一些声明的代码顺序提前了，所以就产生了变量声明提升这个问题。）
### 函数声明提升：
因为JavaScript中的函数是一等公民，函数声明的优先级最高，会被提升至当前作用域最顶端，所以第一次调用时实际执行了下面定义的函数声明，后第二次调用时，由于前面的函数表达式与之前的函数声明同名，故将其覆盖，以后的调用也将会打印同样的结果

# 正确描述变量作用域问题 
全局，局部
# query的优点？
  <1>.JQuery实现脚本与页面的分离 
  <2>.最少的代码做最多的事情 
  <3>.性能支持比较好
  <4>.它是一个“标准” 
  <5>.插件发开
  <6>.节约学习成本
  <7>.让JS编程变得有趣 

# 描述页面的加载顺序(包括css文件和js文件)？
  1.总的来说就是按照html文档的顺序加载
  2.还有就是最好将无论内部或是外部JS文件放到所有html内容之后，这样会令用户感觉页面加载速度变快了，否则如果将所有外部文件（包括css和JS）引用都放到＜head＞中，意味着必须等到全部的JS代码都被下载解析和执行完毕后，才能开始呈现页面的内容（当浏览器遇到＜body＞）,这样会导致呈现页面时出现明显的延迟，二延迟期间的浏览器窗口将是一片空白。
  3.js和css的顺序不是绝对的,跟你页面中使用的顺序有关系。放在上面的会先加载。通常都是把css放上面,js会放在下面。
  
### 1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 

2. 浏览器开始载入html代码，发现＜head＞标签内有一个＂＜link＞标签引用外部CSS文件。 

3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 

4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 

5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 

6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 

7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它。 

8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜style＞（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 

9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 

10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 

11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

# $(document).ready()的作用？
  $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。
  $(document).ready()可以同时编写多个，并且都可以得到执行
  $(document).ready(function(){})可以简写成$(function(){});
  $(document).ready() 方法是事件模块中最重要一个函数，可以极大的提高 Web 应用程序的速度。
  
# 简述scirpt标签的async 和defer属性？
#### async: 布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用
      (即没有src属性的脚本）。就是一边加载执行js, 一边加载页面
#### defer: 异步加载js文件，但是执行被延迟到了文档解析完毕之后(对内联代码可能无效).
     文档解析完毕：页面所有的标签都已经被解析，但是并不是所有的资源都已经被加载完成(比如：
     img标签被加载了，但是指定的图片可能并没有显示出来)
     
# 
