2016.11.28

面向对象的高级语言 web后端

python 主要在web服务器编程，数据挖掘，自然语言处理，自动化测试等方面  LAMP（linux apache mysql python/php/perl）


存储器：主存储器，外存储器，寄存储器

进制转换：
10进制转换2进制：10进制数除2  余数从下网上写
2进制：　
8进制：数字范围0-7：3位2进制算一位。在前面加0表示8进制
16进制：数字0-15；4位2进制算一位。在前面加0x表示16进制

查看ascii码 ：man ascii

一个python文件就是一个模块 有可能是自己写的 也可能是系统提供的库文件
模块包含语句 语句包含表达式 表达式建立并处理对象

python程序是按着顺序执行的 但是类，函数等语句块需要调用后才能执行具体内容。

python关键字： 有特殊含义的单词 可以实现特定的功能

循环判断：
 if: if语句关键字
 elif: else if 条件分支关键字
 else:
 for: for循环关键字 可能搭配in使用
 while: while循环关键字
 break: 循环控制 跳出循环
 continue:  跳出本次循环
 and: 逻辑与
 or: 逻辑或
 not: 逻辑非
 is : 逻辑判断是否为同一对象
 in: 逻辑包含

函数模块类：
 from: 从某个文件当中引入模块
 import: 引入什么内容
 as: 当做什么 一般用作生成新的对象
 def: 定义函数
 pass: 空语句占位符
 lambda: 54544e674-pdk
 class： 定义类

异常：
 try: 异常检测
 except: 异常处理
 finally: 异常执行
 raise: 抛出异常

其他：
 del: 删除一个变量/对象
 global: 声明使用全局变量
 with: 形成一个对象
 assert: 断言处理
 yield: 函数的中断返回
 nonlocal: 闭包的关键声明

3和2中不同的地方
3.x: true false none
2.x： exec:常见一个新的进程 print

核心数据类型
数字（整形int和浮点型float） 字符串（string）列表（list）字典(dict) 元祖（tuple）集合(set)文件
其他类型：类类型（object）none(nonetype) 布尔型(boolean)
编程单元模型类型：函数（function）模块（module）

內建函数： 系统自带的函数
内存的最小存储单元是字节
id：每个字节的标号地址  作用：在同一地址的内容是一样的
type:显示数据的类型

常量：不能给改变的量
变量：认为设定有的标识符，用起来标记常量，可以被重复利用赋值

标识符命名的规则：
1.标识符由一个或多个字母，数字或下划线组成
2.标识符的第一个字符必须是字母或下划线
3.标识符不能与关键字相同
4.python语言是严格区分大小写的

标识符默认规则
1.以单一下划线开头的变量名（_x） 不会被fro module import 语句导入
2.前后双下划线的变量（_x_）为系统的默认变量
3.前面连两个下划线开头的变量（__x）为类的私有变量

python属于弱类型变量：赋值给变量什么类型的值 变量就是什么类型

同时给两个变量赋值：a,b = 1,2 用逗号隔开
两个数交换 1.a,b = b,a; 2.（（a ^= b） （b ^= a） （a ^= b） 只对整数有效） 3.temp = a a = b b = temp

四则运算：
 /取整除数（结果就有小数） %取余 2.8 = 5.8 % 3 运算中有小数
python3中：整数相除不取整 商得多少就显示多少  // 和python2中的/相同是 取整除数

位运算:
右移 a >> 2 位 表示在最右边加两个0 相当于乘4
左移 a << 2 位 表示删除最右边两位数 相当于除于4取整

a | b 与 两个数2进制进行比较 只要有一个数是1就取1
a & b 或 两个数2进制进行比较 只要有一个数是0就取0
a ^ b 异或 两个数2进制进行比较 相同取0 不同取1
~14 取反 -15

逻辑运算 ： 要么真要么假  0是假 非0是真
== (！=) or或 and与 not非 is判断两个对象是否为同一个对象 (is not) in （not in)
支持连逻辑运算 a > b > c   +=等 a+=1相等于a=a+1

强制转换 ：
a=1.234 int(a) 1 取整数 dir(math) 显示math中的内容
import math 引用math这个数学库
math.sqrt (a): a开方
math.pow(a,b): a的b次方
math.trunc(a): 如果a是小数，省去小数部分　或者int(a)函数 也可以省去小数部分
math.floor(a): 对a向下求整，他的值小于或等于a
math.ceil(a) : 对a向上求整，它的值大于或等于a
math.pi: 这个数学常量等于3.141592.....
math.e 这个数字常量e＝2.718281.....
math.log(x[,base]) :对数运算(幂次方)，默认基地为e的对数运算。　如：math.log(8,2) 3.0
math.fabs(a)　：对a取绝对值
math.factorial(a):　求a的阶乘
math.exp(a): 求e的a次方

random模块
import random 引入random模块
random.random():随机生成一组数
random.choice(数据数据类型)　：　在这个数据类型中随机挑选一个




2.a b c 分别附一个整数值 求 这三个数组成三角形的面积 （s=（a+b+c）/2 面积=(s*(s-a)*(s-b)*(s-c))开方）
3. 第二部分　第5章和第6章

集合：
集合:一些唯一的，不可变的对象的一个无序集合（collection）
一个项在集合中只能出现一次，不管将他添加了多少次。
可以迭代，可以根据需要增长或者缩短并且能够包含各种对象的类型。
内置函数set　创建一个集合　x = set('abcdef')  {'a','b','c','d','e','f'} y = set('ab')
如:'a' in x　　true
俩个集合之间还可以左运算　
－ 减去另一个集合中和自己相同的
｜合并两个集合
&  两个集合中相同的部分
^ 两个集合中不相同的部分
{'a','b'} < x　true
x > y true

intersection:
z = x.intersection(y) ｚ中包含的是ｘ和ｙ不同的元素
z.intersection((1.3.5))　输出ｚ中和后面那个集合中不相同的元素
add：插入一个元素一个集合中　x.add('123')
update:集合中加入元素　x.update(set(['x','y']))
remove:移除集合之那个的一个元素　x.remove('b') 移除元素b

列表和集合之间的转换　
set(a) 过滤掉列表中重复的值

round(a,num)函数：　四舍五入，num对ａ小数后几位进行四舍五入

float(a) 将整数转换为浮点数；

oct(a): 将ａ转换成８进制显示出来
hex(a): 将a转换成１６进制显示出来
bin(a): 将ａ转换成２进制显示出来

int(a,base)函数；用来让一个８进制和１６进制数的字符转化变为正常的整数base的参数为２，８，１６．
ecal(a):也可以转换，但是运行取来开销更大有可能导致安全问题；

转义字符：
\n 换行
\r　回车
\f 换页
\\ 代表一个反斜杠

内置函数对象
对象类型：核心数据类型
数字　　　　　　　　１２３(整数)，３.２３(浮点数float:带小数部分的数字)，３＋４j,decimal(小数)，fraction(分数)
字符串　　　　　　　'spansakj',"asdfasf's",b'a\xolc'
列表　　　　　　　　[1,[2,'three'],4]
字典　　　　　　　　{'food':'spam','teste':'yum'}
元祖　　　　　　　　(1,'spam',4,'U')
文件　　　　　　　　myfile=open('eggs','r')
集合　　　　　　　　set("abc"),{'a','b','c'}
其他类型　　　　　　类型，none,布尔型
编程单元类型　　　　函数，模块，类
与实现相关的类型　　编译的代码堆栈跟踪

出现的错误：
syntaxerror:语法错误
当中文编码格式不被识别时　在最上边或第二行加入　＃coding=utf-8　或者　#-*- coding = utf-8 -*-

字符串：零个或多个字符组成的有限串行，空格也是字符　不可变类型。
空的字符串是 false 带空格的字符串是　True
三引号可以在下一行中继续输入''' '''　按原格式输出　生成帮助文档
\　换行符　在下一行输入　但在同一行输出
a='asdasd'
len(a)函数 :　显示字符串a的长度
a[num]: num:索引值 　如a[1]:s　索引是从０开始，第一个索引为０，第二项为１，依次类推　还可以反向索引a[-1] 'd'
a.lower() 将大写变成小写的
a.count("l")  查看l的个数
a.replace('l'.'L') 替换　将小写的l变成大写的legal
a.find('e')　查找第一个e的下标
a.index('L')　查看Ｌ下标
a.upper() 将小写转化为大写的
a.split('　') 分割 　以空格为分割　分割成几部分
s='*'.join(a) s等于以*为拼接的l
a.isdigit()  判断a中是否都是数字
a.startswith('imooc'): 以imoosc开头的行
a.endswith('imooc'):以mooc结尾的行
将字典元祖字符串　转换成列表　list(a)

分片操作：
一般的形式为x[i:j:k] 表示：取出在x中从索引值为i,直到但不包括索引值为j的内容,k表示步长　表示每k个取一个
a='asdasd'
a[1]: 's'
a[-1]: 'd'
a[1:3]: 'sd'
a[1:]: 'sdasd'
a[0:3]: 'asd'
a[:-1]: 'asdas'
a[:]: 'asdasd'
a[::-1] 'dsadsa' 逆向取值 每一个取一个
a[::-2] 'das' 　　逆向取值　每两个取一个
a[-1:-5:-2]  'da'
a[2::-2] 'da' 在２前边的每两个取一个

支持　＋　＊　进行合并/重复
a + 'xyz' 'asdasdxyz'
a * 2 'asdasdasdasd' 把整个字符串×２
repr(123) '123' 强转
｀123｀ '123' 强转成字符串　　python３中没有反单引号这个强转
str(123) '123' 强转

不能改变原来的字符串　创造一个新的字符串
数字，字符串，和元祖是不可变的　列表和字典可以完全自由的改变

a = 'z' + a[1:] :表示把z代替第一个数
a = 'z' + a[2:] :表示把z代替前两个数
a.find('a')  查找字符串a 找到返回索引值，找不到返回-1
a.replace('a','sf') ：对全局进行搜索和替换

line = 'aaa,bbb,cccccc,dd'
line.split(",") ['aaa','bbb','ccccc','dd']  把，号作为分隔符把他们分割单一的部分
line = 'aba,cbc,dbd'
line.split('b') ['a','a,b','c,d','d'] 把ｂ作为分隔符
a.upper() 把a的字符全部都变成大写的
a.isalpha()　检查a中是否全部是字母　是返回true 否则返回false

输入：从终端输入相应的值在程序中　获取
raw_input(): 无论输入任何内容　都当做字符串处理并返回
加一个强转int(raw_input()) 输出整数

input:输入什么类型　输出什么类型　输入字符串时要加引号

python3中没有了raw-input: 只有input 作用和raw_input一样　

exit(): 结束进程；

输入三个数　求三个数的根

print: 输出
pathon2中：　
print "hello world",print "nihao world" 两个输出之间加逗号不换行　
不同字符串之间加逗号不换行
python3中：
print ("hello") 要加括号
不换行在后面加一个  ,end=""

格式化输出：
%d: 传入一个整形的　
％s：传入字符串　
％u: 不带符号的十进制
％x:不带符号的１６进制
%X：不带符号的１６进制
%o:不带符号的８进制
％e：科学计数法表示的浮点数
％E：科学计数法表示的浮点数
％f/F:十进制的浮点数
%g:如果指数大于－４或者小于精度值则和e相同，其他情况和f相同
%G:如果指数大于－４或者小于精度值则和e相同，其他情况和F相同
%c:单字节
$r:字符串
％s:字符串
如：print "the lenght is %s hello "%变量　print "the lenght is %s　％s hello "%(变量，变量)　传给两个数
打印一个％　用％％　输出一个％
修饰符：
１．%字符：标记转换说明符的开始
２．转换标志：－ 表示左对齐；＋表示在转换值之前要加上正负号；“”（空白字符）表示整数之前保留空格；０表示转换值若位数不够则用０填充
３.最小字段值：转换后的字符串至少应该具有该值指定的宽度。如果×，则宽度会从值组中读出
４.点（.）后跟精度值：如果转换的是实数，精度值就表示出现在小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。print "this is %5.2f"%a 表示小数点后占两位　四舍五入
５.字符串格式化转换类型。

注释：＃　
‘’‘　文档的解释　’‘’　　多行注释的作用　不是多行注释　对文档解释作用
print math.__doc__　　查看模块的信息

列表：
列表：表示一种容器类型，有序的,可以是混合的　序列从０开始  是可变数据类型　支持切片操作　[]中括号是列表
l = [1,5，‘hello’,[4,8,6]] 　定义一个列表　
l[1] 5      l[3][1] 8
l[0] = 2 　　改变l中的第一个数
l.append('a') 向列表的末端加入a 　　　append : 附加
l.extend([5,6]) 合并两个列表　　　　　extend: 扩展
l.insert(3,2) 在下标为３的位置插入２　insert: 插入
l.index(5) 显示５的下标　１　　　　　　index: 指标　做索引　　　
l.count(2) 显示２的个数　　　　　　　　count: 数
l.sort() 排序　默认从小到大排序　　　　sort : 排序
l.pop()  显示最后一个元素　　　　　　　pop:　流行
l.reverse() 反转　　　　　　　　　　　reverse: 反转
del l[２] 删除下标为２的数　　　　　　　del:删除
len(l) 判断列表的长度
l.remoove(2) 删除值为２的数

列表和元祖的区别　　　　　　　　　
列表可变　元祖不可变

元祖：
是一种容器类型，是任意对象的有序集合，通过索引访问　不可变类型　可以分片　()小括号是元祖
t = (1,2,3)  建一个元祖
可以加法和乘法
元祖只有一项是　加一个逗号

字典：通过键值对来实现元素的存取，是一种无序的集合，容器可变，可改变的　大括号｛｝没有运算 键：可以是数字或字符串，值什么类型都可以 内部查找是：散列查找
  d = {‘a’:1,'b':2,'c':3}
  获取字典中的遍历的方法：
  d = {1:111,2:222,5:555}　
  for i in d:
    print d[i]
  d['１'] = "value"
  d['b'] = "bbb"
  常用操作方法：
  d.keys()   列出所有的键
  d.values() 列出所有的值
  d.items() 　列出所有的键和值　每一对形成一个元祖
  d.get("a") 获取键a的值
  d.update(d2)  合并
  d.pop(key)     弹出某一个　字典中弹出的一个消失
  del d[key]     删除 　用中括号
  a = dict(zip(x,y)) 两个元祖x,y或者其他转换成字典
  d.items():     把字典变成一个打的列表　每一个键值队是一个元祖
  for i,j in d.items(): i会被键赋值　j会被值赋值
  数字　字符串　列表　字典　元祖

  bool:只有两种　true false
  none　类型是　nonetype

集合　无序排列，可包含不同数据类型　支持成员关系测试　大括号{}　只能整体使用不可以取数　不可以有重复的项
  s = {[1,2]} 定义一个集合
  s = set([]) 定义一个空集合
  s = {1,2} 定义一个集合
  s=frozenset({1,2,3}) frozenser定义的列表不可变　　　frozen:　冰冻
  集合方法：
  s.add(5)　　　　　　　添加一个值
  s.pop() 　　　　　　　随机弹出
  s.clear()    　　　　清空集合
  s.remove(1)   　　　　删除集合中某个数
  s.diffreence(s1) 　　列出s中有s1没有的项
  s.union(s1)  　　　　 合并s和s1中　相同的只取一项
  s.update(s1)  　　　　合并s和s1　　相同的只取一项
  集合的运算
  s - s1     　　　　　　减去s1中和s中重复的项
  s | s1     　　　　　　合并(并集)
  s & s1    　　　　　　 相同的（交集）
  s ^ s1    　　　　　 　不相同的（补集）

数据类型总结：
    bool : 　　 true  false 　逻辑运算得到的结果为bool类型
    nonetype:　  none 　用作空，占位变量
    数字类型　　　整型　　　不可变的　 数学运算位运算等
                浮点型
    字符串类型　　　有序的　  不可变的　＋　*运算　　属性方法　切片操作　in逻辑
    列表　　　　　　有序的　  可变的　　＋　*运算　　属性方法　切片操作　in逻辑
    元祖　　　　　　有序的　  不可变的　＋*运算　　　属性方法　切片操作　in逻辑
    字典          无序的　  可变的　　　　　　　　属性方法　　　　　　in逻辑（键）
    集合   set{}  无序的　  可变的　－｜^& 运算　属性方法　　　　　　in逻辑
      　frozenset 无序的　  不可变　－｜^& 运算　属性方法　　　　　　in逻辑

import copy
如果对copy中的属性进行修改　会对copy有影响　不会影响deepcopy
d = [1,2,[3,4],5] 对d进行任何操作都会影响m 对[3,4]　操作会影响m l  不会影响k
m=d
l= copy.copy(d)
k=deepcopy(d)

语句块：多条语句形成的整体

语句结构：顺序结构　分支（选择）结构　if else elif　循环结构 for in while else break continue

if 判断条件:
  执行内容/pass　　　pass:占位符　什么都不执行


if 判断条件：
  执行内容
else:如果if条件不成立时执行这个
  执行内容

三元运算：
x if 判断条件 else z 如果判断条件是真的返回x,如果判断条件是假返回z

if 判断条件１:
  执行内容
elif 判断条件２:　当判断条件１不成立时执行这个　可以嵌套无数个这个
  执行内容
else:当判断条件１/２都不成立时　执行这个
  执行内容
range　快速生成一个序列
range（i,j,[步进值]）：i:起始值　j：终止值但不包括　
range(10) 生成一个0到10的序列
srange(10):形成一个迭代对象

fot循环：
for i in n: n可以使字符串　元祖　序列　表达式　等
  执行代码内容
"迭代指重复执行一个命令"

序列：
序列：是指列表，字符串，元祖三个类型
特点：１．可以通过索引来抓取特定的项目
    　２．可以切片
max(x) :返回最大值 返回x中最大的值
min(x)：返回最小值 返回x中最小的值
*: 重复　str*5 str　重复５次
cmp(x,y):比较２个序列值是否相等。字母的字符串长于数字的字符串１表示前面长于后面　－１表示后面长于前面　０表示相等

获取一个索引的方法
for i in range(len('hello')):
    print i
获取序列中的值的方法 遍历
for i in "hello"
  print i

s = "hello"
for i in range(len('hello')):
    print s[i]

while 判断语句:
    执行内容

while 判断语句:
    执行内容
else:
    执行内容

break:　　　循环体结束　　 　
continue: 跳出本次循环　执行下次判断　再循环

import random　     　　引入随机模块
random.randint(1,10)　　随机出现１到１０之间的数

for循环：
for 变量　in　列表:
    语句块

for 变量　in　列表:
    语句块
else:
    语句块
range(x,j,z) : 生成列表　可以有 x开始　y结束(不包含y)　z步长的参数
同时满足多个变量的赋值　前面几项后面必须几项
for (i,j) in [(1,2),(1,2),(1,2)]:
print i,j

[x for x in [1,2,3]]  生成[1,2,3]
[x+1 for x in [1,2,3]] 生成[2,3,4]
[x+y for x,y in [(1,2),(3,4)]] [3,7]
[x for x in range(101) if not x % 2]

impout time
  time.sleep(2)   每２秒运行一次
控制语句总结：
顺序执行，选择分支，循环
分支语句　if elif else
         简单的if语句
         if...else
         if...elif....else
         if 的嵌套

         x if y else z

循环　while...else
     死循环
     循环结束条件
     与break continue配合

     for  ...else
     多种形式的集合类型
     与range的配合
     多个变量接收
     [x for x in range(100)]

break:　　　结束循环
continue:　跳出本次循环
pass:　　　　空占位符

zip(t1,t) :形成一个元祖　如果t,t1都是　列表　那么生成生成一个大的列表其中包含几个元祖
dict(zip(t1,t)) 生成字典

电影　（社交网络　乔布斯）

函数
函数是一个完成特定功能的代码模块，其程序代码独立，通常有返回值，也可以是空值。最小的封装单元　

为什么用函数：
１.可以重复使用　　2.增加封装特性　１）代码保密　２）规定使用方法　３）无需了解实现机制　４）使代码美观
內建函数：
系统定义好的　dir(__builtin__) 查看内建函数

方法　
在一个类中的函数叫方法

API(接口)
是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节

函数三要素：
１.功能: 确定函数的功能是设计一个函数的前提。所谓功能就是函数最终要实现什么，决定了一个函数的复杂程度，运用什么方法，还是呢么样的逻辑设计　
２．参数 :也叫参变量，是一个变量。也成为形参，通常在函数没有被调用时候形参
３．返回值：返回值是函数执行结束后调用形式返回给调用者的结果。如果一个单纯的功能函数那么也可以没有返回值。没有返回值默认返回none　如果有返回值则用return标识
del 函数名(参数值(可以加也可以不加)):　　定义一个函数
  函数内部的功能（语句块)
  return 返回值　１，２，３，４　可以多个返回值　函数执行到return的时候　函数立刻结束　后面的不会执行了
r = 函数名() r　＝　返回值　　
print 函数名()  输出语句块和返回值
函数名()  　调用一个函数
例：　　　
def fun1(a,b):
  return a+b,a-b
print fun1(3,2) 输出(5,1) 以元祖的形式传出

传参：
当传入的是一个不可变类型的数据类型的时候，为值传递　内部改变　外部不改变
当传入一个可变类型的时候，相当于是一个地址传递　内部改变　外部改变　让外部不变方法　例：l = [1,2] a = l[:] 传入副本a　外面不会改变
形参定义函数的写法：
１．定义位置参数的函数
def fun(a,b):
    print a,b
fun(1,2)
２．定义默认值传参 允许什么都不传　打印默认值　传入一个数　输入传出的数 默认值参数必须放在后面
def fun1(a,b = 100,c=1000):　
    print a,b,c
    fun1(1,2)
３．*传参  收集位置参数　　可以传入任意数目的参数
def fun2(*a):        fu2(a,*b) 把第一个传给a 剩下的传给b
    print a
    fun2(1,2,3,4,5,6)
４．**传参　收集字典的方式
def fun3(**a)   　　　必须这个顺序a,d=100,*a,**a
    pringt a
    fun3(a = 1,b=2)
在python3中可以这样 2中不行
def fun4(*a,b):
    print （a,b）
    run4(1,2,3,b=100)
传参过程中：
def fun(a,b):
    print a,b
1.位置传参
fun(1,2)
2.关键字传参
fun(b = 1,a = 2) 要求名字和关键字名一样
3.*传参
l = [5,6]
fun(*l)
4**传参
d = {"a":1,"b":2}  ＝＝＝＝》a = 1,b = 2
fun(**d)

def fun1(x,*args,**kwargs):　传递多少参数都可以　＝＝＝＝＝》def fun1(x,*a,**b):

题：写一个函数　第一个是一个　字母　第二个是一个字符串
写一个函数　传一个字符串　去掉空格　打印出来

作用域:
  在函数外部　定义的是全局变量　在函数内部　定义的是局部变量
  全局部分不能够使用局部变量，局部部分可以使用全局变量
  当局部变量和全局变量重名时，在函数内部默认使用局部变量

global：想修改全局变量　用global　进行声明
  变量查找顺序：函数内－类内－模块内－内置变量

周末任务：
总结上周的代码
看第四部分　１６　１７ 18章
练习：
函数传入一个列表　列表变成所有的奇数都在偶数前边
有一个列表　[1-9]　输入3 [7,8,9,1-6]　

函数的嵌套作用(闭包)
  允许在一个函数内部进行函数定义。工厂函数或闭包。
  函数内定义一个函数可以自动的返回内定的功能
  python3中新加入的关键字 　　　　　nonlocal:局部
  nonlocal:用来在函数或其他作用域中使用外层（非全举报）变量。主要是在函数嵌套中的内层函数使用外层函数的变量如果不加nonlocal　可以打印但是不能修改，添加这个后可以修改
  如：def fun_out():
        a=4
        def fun_in():
            nonlocal a
            a += 1
        fun_in()
        print (a)
      fun_out()

递归函数:
  所谓的递归函数是指一个函数的函数体中直接调用或者简介调用了该函数自身的函数。
递归函数调用的执行过程分为两个阶段：
  递推阶段：从原问题出发，按递推公式从位置到已知，最终达到递归终止条件
  回归阶段：按递归终止条件求结果，逆向带入递归公式，回归到原问题的求解
  def recursiver(n):
      if n <= 1:
        return 1
      return(n * recursive(n - 1))
  r = recursive(5)
  print ('5 = %d'%r)

匿名函数：一种生成函数对象的表达式，称之为lambda。
  定义形式　lambda 参数１,参数２,参数３....：表达式
  如：
  f = lambda x,y,z:x + y +z
  f(2,3,4)
  9
面向对象：object oriented,oo
  是一种对现实世界理解和抽象的方法，是计算机编程奇数发展到一定阶段后的产物。
什么是对象：在面向对象编程（oop）中，对象指行动或思考时作为目标的事物。python是一门面向对象的编程语言，一般具有以下特性：
  一切事物皆对象
  对象具有封装和继承特性
  对象与对象之间用消息通信，各自存在信息隐藏
对象的特征：
  对象：一个对象有自己的状态，行为和唯一标识；所有相同类型的对象所具有的结构和行为在他们共同的类中被定义
  状态：包裹这个对象已有的属相和对象具有的当前属性。
  行为：是指一个对象如何形象外界及被外界影响，表现为对象自身状态的改变和信息的传递
  标识：是指一个对象所具有的区别于所有其他对象的属性

面向对象的思想：
  面向对象的程序设计语言必须有描述对象及其相互之间关系的语言成分。这些程序设计语言可以归纳为以下几类：
  系统中一切事物皆对象；
  对象是属性及其操作的封装体；
  对象可按其性质划分为类，对象成为类的实例；
  实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；
  方法是消息的序列
  程序　＝　指令　＋　数据
  代码可以选择以指令为核心或数据为核心

两种范型：
  １．以指令为核心：围绕“正在发生什么”进行编写
  面向过程编程：程序具有一系列线性步骤；主体思想是代码作用于数据。比如c语言
  ２．以数据为核心：围绕“将影响谁”进行编写
  面向对象编程(oop)：围绕数据及以为数据严格定义的接口组织程序，用数据控制代码的方位。

类：
什么是类：是一种面向计算机编程语言的构造，是一个概念，是创建对象的模板，描述了所创建的对象共同的属性和方法。
类的的数据和代码：即类的成员
  数据：成员变量或实例变量
  成员方法(函数)：简称为方法，是操作数据的代码，用于定义如何使用成员变量；因此一个类的行为和接口是通过方法来定义的。
  方法和变量：
  私有：内部使用
  公共：外部可见
类的创建：
  class　Person(obje０ct(表示最大的根)或继承关系): 类名首字母通常大写
    age = 10
    name = 'lilei'
    写了下面一个就不用写上面那个name
    def __init__(self,name):  不需要调用　每次实例化都会执行
        self.name = name

    def color(self,color):    self是必须写的　实例的对象给self
        self.language = 'englist'  增加一个共同属性
        print '%s is %s'%(self.name,color)
  lilei = Person('lilei')   直接传给init那个　属性
  lilei = Person
  lilei.sex = 'Man'　       增加一个私有属性 当私有属性和公共属性冲突时，被应用私有属性
  lilei.color('black')     　调用函数
  lilei.language           　上面先调用了函数　才可以这样写　
  对象名 = 类名()  生成一个对象
  对象名.属性名　调用一个对象的属性

__init__  　　　　　初始化一个对象 自动执行　不需要调用　每当实例化对象的时候
__del__　　　　　　　当你的对象被销毁的时候会执行　或者程序结束时　最后执行
__new__(cls) 　　　　创造一个对象

类方法和静态方法：
普通方法：
  class TestStaticMethod(object)
    def foo(self):
      print "calling static methid foo()"
A = TestStaticMethod()
A.foo()

静态方法：与普通方法的区别是不用传参
class TestStaticMethod(object):
　＠staticmethod                      声明一个静态方法,可以完全取代下面那种声明方法
  age　＝　10
  def foo():                          静态方法不用传参
    print TestStaticMethod.age   　　 直接用类名调用
    print "calling static method foo()"
  foo = staticmethod(foo)       　  　 声明一个静态方法
A = TestStaticMethod()
A.foo(1)　　　　　　　　　　　　　　　　　　调用函数　和下边的重复使用一个就行
TestStaicMethod.foo()　　　　　　　　　　可以用类名直接调用函数

类方法：
class TestClassMethod(object):
  @classmethod                           声明一个类方法，可以完全取代下面那个声明
  def foo(cls):　　　　　　　　　　　　　　　　调用这个函数的对象传给cls
    print 'calling class method foo'
    print 'class',cls.__name__　　　　　　打印出类名 类名.__name__　显示类名
  foo = classmethod(foo)         　　　 声明一个类方法
B = TestClassMethod()
B.foo()                                调用函数　和下边那个重复　使用一个就行

TestClassMethod.foo()             　　 直接用类名进行调用函数
继承
  mro函数 继承关系的了解
  继承描述了基类(父类)的属性如何“遗传”给派生类(子类)。一个子类可以继承它的基类的任何属性，不管数据属性还是方法。
  class 子类(父类):   继承
继承的好处：
  １．可以实现代码的重用，继承了父类的属性和方法。但是子类中有属性和父类中重名，在子类中覆盖掉父类属性

format函数：
  s = '{} is about {}'.format('zhangsan','lisi')  把zhangsan 传给第一个大括号　把lisi 传给第二个大括号 打印时大括号消失
  s = '{1} is about {0}'.format('zhangsan','lisi')  把lisi 传给第一个大括号　把 传给第二个大括号 打印时大括号消失

super：使用父类中被子类覆盖的方法
  在类中添加时
  super(子类名，self).方法名()
  调用时
  super(子类名，实例对象名).方法名(none/参数)

__metaclass__  :声明下面建的类都是新类　新类中类名后面要加(object)

多重继承：对个父类中间用逗号，属性冲突，顺序：自己－－》第一个父类－－》第二个父类．．．．

继承检测：
  issubclass(子类,父类)
封装：是对全局作用域中其他区域隐藏多余信息的原则。
  继承、封装和多态被称为面向对象编程的三个重要特征
  将类或者函数中的某些属性限制在某个区域内，外部无法调用
  不希望别人对代码进行更改
双下滑线的意义：
类的私有属性
  双下滑先开够的属性为私有属性，不能在类的外部被使用或直接访问，在类内部的方法使用时self.__private_attrs
私有的类方法
  两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部用self.__pribate_methods
  以单下划线开头的类被私有化　不能被引用　　　　　　　
  以双下划线开头的变量不会被from import *所引用　　称为私有化变量　不能被继承
魔法方法、属性
　dir(a)     查看a的魔法方法和属性
  __doc__　　打印出类a的帮助文档
　__class__  查看a属于那个类
　__dic__
  __getattr__  当你调用一个不存在变量的时候就会调用
  __setattr__  当你给一个不存在变量赋值的时候会调用
  __call__     用类生成的对象　用类似函数的方法：a(200) 这样来调用和传参


迭代器：
  迭代算法是用计算机解决问题的一种基本算法
  __iter__     迭代
生成器：
  yield :相当于return的功能　返回值出去　循环不结束　记录执行位置　继续向下执行＝１

错误和异常：
  错误：人为的不符合规定 人为可以避免的
  异常：外界环境导致程序无法正常运行

异常处理:(代码：异常处理.py)
  AttributeError:属性错误，特性引用和赋值失败时引发的
  NameError:试图访问的变量名不存在
  SyntaxError:语法错误，代码形式错误
  Exception:所有异常的基类
  IOError:一般常见于打不开不存在文件时引发IOError错误，也可以理解为输出输入错误
  KeyError:使用了映射中不存在的关键字(键)时引发的关键字错误
  IndexError:索引错误，使用的索引不存在，常索引超出序列范围
  TypeError:类型错误，內建操作或函数应于了错误类型的对象时会引发类型错误
  ZeroDivisionError:除数为0,在用除法操作时，第二个参数为０时引发了该错误
  ValueError:值错误，传给对象的参数类型不正确，像是给int()函数传入了字符串数据类型的参数。

  1.try....except
    只检测try和except的部分，如果没有出现异常　直接执行，如果try后面出现异常直接跳转到except下面的语句继续执行　如果except后面加一个异常　处理就会按加的那个异常去处理　如果不是那个异常会报语法错误
    多个异常处理：多加几个　except 异常：
  2.try..except..else
    产生异常else不执行　不产生异常执行else
  3.try..except..else..finally
    无论是否发生异常都执行
  产生一个异常对象
    as e或者,e
    import itrceback
    traceback.print_exc()
  主动抛出异常
    raise主动抛出一个异常　只要raise执行了　就产生一个异常　下面都不执行
  如果自定义一个异常　定义的异常类必须继承Exception这个类(代码：异常类.py)
断言assert语句(代码：assert.py)　判断语句　
  断言是一种调试方法
  assert 后面加条件语句: 不满足时抛出一个异常　
  assert语句中用于在程序中引入调试代码
  assert condition[,expression]
  如果condition条件不满足，则assert不做任何操作
  如果condition条件不满足，则assert使用expression作为参数实例化AssertionError并引发结果实例
  使用情况：
    防御性编程
    运行时对程序逻辑的检测
    合约性检查（比如前置条件，后置条件）
    程序中的常量
    检查文档
with...as...语句：(代码：with.as语句．py)
  生成一个对象　执行结束后自动销毁生成的对象
  with 表达式的值 as 变量
模块：
  模块是最高的常旭组织单元，他将程序代码和数据封装起来以便重用。从实际角度来看，模块往往对应python程序文件，每一个文件
  就是一个模块。
  三种模块：１．自己写的２．标准库３．第三方　使用需要下载
  每个模块都有自己的命名空间
导入模块：(模块，模块１)
  import语句：　将整个模块导入到这个空间　调用要加上模块名
    import 模块名　就是文件名　不加后边的.py
    第一次导入生成字节码文件
    导入指定的整个模块，包括生成一个以模块命名控件的命名控件
  from 模块名　import 类，函数名　指定模块属性导入到本地空间　多个用逗号隔开　调用直接调用
  from 模块名　import * 导入模块中的所有属性但不包括__和_的属性或类
当模块不是被调用的时候　__name__等价于__main__
当模块是被调用过来的时候__name__会打印模块名称
reload(模块名)　重新载入一个模块
包：文件夹
  包的导入:需要在dir和dir1中创建一个__init__.py
  　import dir.dir1.modile   包的导入
    m1 = dir.dir1.module.A()　类的实例化
    m1.a()                    函数的调用
    dir.dir1.module.b()       函数的调用
    第二种调用方法
    from dir.dir2　import module2   包的导入 或者直接　from dir.dir2.module2 importC,d 以后使用直接用属性就可以调用
    m2 = module2.C　　　　　　　　　　　　　　　　　　　　 m2=C()　　　　　
    m2.c                                            m2.c()
    moule2.d()                                      d()
标准库模块　不要把文件名　和标准块名一样
  sys模块　解释器相关的
    import
    sys.__doc__  查看sys的帮助文档
    dir(sys)
    sys.argv[1] 专门用来向python解释器传奇命令行参数
　　　　sys.exit() 用来退出当前程序
　　　　sys.path() 查找目录所在模块

  os模块　和系统相关的文件
    os.rename(old,new) 重命名一个文件
　　　　os.remove(filename)  删除一个文件
　　　　os.system(command)   执行系统命令
　　　　os.exec()          　 括号中执行python命令
    fp = os.popen('ls -l','r')  执行ls -l命令并把内容返回给fp
    print ft.read()
    os.system('ls -l') 执行系统命令　成功返回值为０

  time 获取时间的
    time.time() 获取1970年到现在的秒数
    time.localtime() 以元祖的方式返回一个时间
    time.ctime() 人类可读的方式返回一个时间
    time.clock() 进程占用cpu的时间
    time.sleep(１)　程序睡眠多少秒

判断字符串是否为数字：isdigit()
判断字符串是否为字母：isalpha()

正则表达式：
    字符匹配
    []　:指定一个字符类别　例如：[abc]和[a-c]都是匹配a,b,c中的任意一个字符：只想匹配小写字母:可以写成[a-z]
    ^　:补集　例如：[^5]将匹配5之外的任意字符
    \　：转义字符。例如:\[ 打印出[
    一些用“\”开始的特殊字符
    \d 匹配任何十进制数；它相当于[0-9].
    \D 匹配任何非数字字符;它相当于[^0-9]
    \s 匹配任何空白字符；它相当于[ \t\n\r\f\v].
    \S 匹配任何非空字符；它相当于[^ \t\n\r\f\v]
    \w 匹配任何字母数字字符；它相当于[a-zA-Z0-9]
    \W 匹配然和非字母数字字符；它相当于[^a-zA-Z0-9]
    这些特殊字符都可以包含在一个字符类中.如，[\s,.]字符将匹配任何空白字符或 “，” 或　“.”
    .　:它匹配任何除了换行字符外的任何字符。通常用在你想匹‘配任何字符’的地方
    重复
    *　:指定前一字符可以被匹配零次或多次，而不是一次。例如：ca*t将匹配"ct"(０个‘a’字符) a[bcd]*b 将匹配字母"a"，零个或多个来自类[bcd]中的字母，最后以"b"结尾
    +　:表示匹配一次或更多次。和*的区别是　它要求别匹配的字符至少出现一次　例如：ca*t将不匹配"ct"
    ?　:匹配一次或零次；你可以认为它用于标识某事物是可选的。例如：home-?brew匹配"homebrew"或"home-brew"
    {m,n｝:其中m和ｎ是十进制整数，该限定符的意思是至少有m个重复，至多n个重复。例如：a/{1,3}b将匹配“a/b”,"a//b"和"a///b"。它不能匹配"ab"因为没有斜杠，也不能匹配"a////b"，因为有４个
          可以忽略m或n;因为会为缺失的值假设一个合理的值。忽略m会认为下边界是0,而忽略n的结果是上边界为无穷大
    {0,}等同于*,{1,}等同于+,{0,1}等同于？最好用*,+,?
    编译正则表达式　import re模块
    正则表达式编译成'RegexObject'实例，可以为不同的操作提供方法，如模式匹配搜索或字符替换。
    import re
    p = re.compile('ab*')
    print p
    re.compile()也可以接受可选的标志参数，常用来实现不同的特殊功能和语法变更。
    Raw字符串
    在字符串前边加个'r'　具有特殊意义的字符就不会被特殊处理　例如：r'\n' 就是包含了“\”和‘ｎ’的两个字符，而“\n”则是一个字符　表示换行
    常规字符串            Raw字符串
    'ab*'               r'ab*'
    '\\\\section'       r'\\section'
    '\\w+\\s+\\1'       r'\w+\s+\1'
    执行匹配
    重要的几个'RegexObject'实例的方法属性　看完整版查看Python Library Reference
    方法/属性　作用
    math()        决定RE是否在字符串刚开始的位置匹配　没有匹配返回None
    search() 　　　扫描字符串，找到RE匹配的位置       没有匹配返回None
    findall() 　　找到RE匹配的所有子串，并把它们作为一个列表返回
    finditer() 　找到RE匹配的所有子串，并把它们作为一个迭代器返回
    group()      返回被RE匹配的字符串
    strat()      返回匹配开始的位置
    end()        返回匹配结束的位置
    span()       返回一个元祖包含匹配（开始，结束）的位置

文件：文件是计算机中非常重要的东西，在python里把文件视作一种类型的对象，类似之前学过的其他类型。
  包括7中文件类型：
    b：块设备文件
    c：字符设备文件
    d：目录
    -：普通文件
    l：链接文件
    s：套接字文件
    p：管道文件 （mkfifo 'fifo'） 创建一个管道文件(在内存中)
  打开关　闭文件
    file = open(r'绝对/相对路径/文件名')　通过路径和文件名打开一个文件
    file_boject = open(file_name,'r',1)　通过文件名
    功能：打开一个文件，返回一个文件流对象。
    第一个参数：file_name-----文件名;路径/文件名/变量
    第二个参数：access_mode-----打开文件的方式，如果不写默认为'r'
              文件模式       操作
               r             以读方式打开，文件必须存在
               w             以写方式打开,文件不存在则创建，存在清空原有内容
               a             以追加的模式打开
               r+            以读写的模式打开文件，文件必须存在
               w+            以读写的模式打开文件,存在清空原有内容
               a+            以读写模式打开，追加模式
               rb            以二进制读模式打开　同r
               wb            以二进制写模式打开　同w
               ab            以二进制追加模式打开　同a
               rb+           以二进制读写模式打开　同r+
               wb+           以二进制读写模式打开　同w+
               ab+           以二进制追加模式打开　同a+
    第三个参数：buffering------0：表示无缓冲，1表示有行缓冲,如果大于1标识直接致命缓冲区大小。如果不写或为负数
                      则表示使用系统默认提供的缓冲机制。
  流：所有的I/O操作仅是简单的从程序移进或者移除，这种字节流，就称为流。
      系统已经默认为我们打开了三个流，在sys模块中：
      标准输入：sys.stdin
      标准输出：sys.stdout
      标准错误：sys.stderr
  缓冲：系统自动在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，
      装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，
      然后再从缓冲区逐个的将数据送到程序的数据区。
  f = open('file','r+')
  f.colse()
      打开一个文件后我们就可以通过文件流对文件进行操作了，当操作结束后使用close()关闭这个流是一个好习惯。可以防止一些误操作
      ，也可以节省资源。此外我们还有一种方法可以不用close：
      with open('file','r+') as f:
        f.__doc__ 进行操作
      因为with生成的对象在语句开结束后会自动处理，所以也就不需要close了，但是这个流只能在with语句开中使用

  读取文件：带[]的意思是，[]里的内容可写可不写
    read([size(字符的多少)])：直接读取字节到字符串中，最多读取给定数目分字节。如果没有给定size参数(默认值为-1)
                              或者size值为负，文件将被取值直至末尾。文件过大时建议在non-blocking模式下使用
    readline([size(字符的多少)])：读取时打开文件的一行(读取换行符结束之前的所有字节).然后整行，包括行结束符，作为
                                  字符串返回。和read()相同，它也有一个可选的size参数，默认为-1，代表读至行结束符。
                                  如果提供了该参数，那么在超过size个字节后会返回不完整的行。
    readlines([size]):返回一个列表　把每一行作为一字符串(项)
  写入文件
    write(string):功能和read()和readline()相反。它把含有文本数据或二进制数据块的字符串写到文件中去
    writelines(str_list)：接受一个字符串列表
  缓冲区刷新
  flush()用于手动刷新缓冲区。
  文件偏移位置：当我们打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置
    seek()方法可以在文件中移动文件指针到不同的位置
    seek(offset[,whence])
    功能：移动文件为止
    第一个参数：offset－－－代表相对于每个位置盘一辆，正数为向后移动，负数为向前移动
    第二个参数：whence－－－是基准位置的默认值为0，代表从文件开头算起，１代表从当前位置算起，２代表从文件末尾算起
    f.tell():获取文件指针位置
  文件内容迭代：直接可以在for循环中地带文件的每一行
    f = open('file')
    for line in f:
      print(line)
    f.next()
    line.startswith('imooc'): 以imoosc开头的行
    line.endswith('imooc'):以mooc结尾的行
    f.next():一行行的显示　f的内容　相当于遍历　每次遍历一行
    f.fileno():获取f的编号

    引入　fileinput模块实行迭代
    import fileinput
    for line in fileinput.input(filename):
        print(line) 读出每一行的数据

  查看文件信息：
    os.stat('file'):查看文件的详细信息
      st_mode:权限模式
      st_ino:inode编号　inode：索引编号
      st_dev:device 设备
      st_nlink:硬链接的数量
      st_uid:所有用户的user　id
      st_gid:所有用户的组id
      st_size:文件大小，以位为单位
      st_atime:文件最后访问的时间
      st_mtime:文件最后修改的时间
      st_ctime:文件创建的时间
      查看单一一个文件信息：
      例如：os.stst('file').st_mode　　　只显示权限模式

    os.listdir('.'):以列表的形式列出当前目录下的文件名，每个文件名用字符串的形式
    os.path.isdir('str')：判断str是不是文件夹
    os.path.isfile('str'):判断str是不是文件
　　　　os.path.link('str'):判断str是不是链接
    file_path = os.path.join('')：路径的拼接
    os.system('ls -l'):执行一个shell命名
多任务编程：


进程：(process)
    init进程是系统的起始进程　只有进程才能使用多核
    程序是静态的，它是一些保存在磁盘上的指令和有序集合，没有任何执行的概念。
    进程是动态的概念，它是程序执行过程，包括创建、调度和消亡进程是程序执行
    和资源管理的最小单位
  进程分类
    交互进程：该类进程是由shell控制和运行的。交互进程即可以在前台运行，也可以在后台运行
    批处理进程：该类进程不属于某个终端，它被提交到一个队列中以便顺序执行
    守护进程：该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。
  进程状态：
  运行态：此时进程或者正在运行，或者准备运行。
  等待态：此时进程在等待一个事件的发生或某种系统资源。分为可中断和不可中断
  停止态：这是一个已终止的进程，但还在进程向量组中占有结构空间
  进程的几组循环
  就绪态》运行(占用cpu)》休眠(等待)》就绪
  运行》停止》就绪
  运行》僵尸态(占用内存)

  linux下常用进程命名：(ps -aux) (ps -ajx) (pstree) (top(动态显示当前进程参数))
          优先级从19-（-20）-２０优先级最高 19最低　0一下的优先级需要root
          nice(改变一个优先级 然后运行)　renice(改变正在运行进程的优先级)
        　使用方法（nice -优先级数　运行程序） (renic -优先级数　进程id)
          kill(向进程发送信号)　kill -l列出当前系统所支持的信号
          kill -9 id号　杀死一个进程
  　-aux
      PID:产生进程时　系统自动给一个唯一的id号
      %CPU:
      ％MEN :占用虚拟内存
      STAT:状态　
            D:不可中断
            S:阻塞状态(可中断)
            Z：不存在但暂时无法消除(僵尸态)
            s：会话组组长
            l：有子进程的
            +：前台运行进程
            R：正在执行中
            T：暂停执行
            <：高优先级进程
            N：低优先级进程
            L:有内存分页分配并锁在内存中

      TIME:占用cpu的时间
      COMMAND:通过哪个命令创建的进程
    -ajx
      PPID: 父进程Id
      PGID:进程组id
      SID:会话组id
    top
      NI:优先级占用cpu(优先级从19-（-20）-２０优先级最高 19最低　0一下的优先级需要root)
线程：（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行都在同一个进程中，共享相同的运行环境。
    我们可以想象成是在主进程或“主线程”中并行运行的’迷你进程‘
  为什么要有线程：由于进程的地址空间是私有的，因此在进程间上下切换时，系统开销比较大。为了提高系统的性能，许多操作
                系统规范里引入了轻量级进程的概念，被称为线程。在同一个进程中穿件的向后才能共享该进程的地址控件，在
                linux中线程和进程都参与统一的调度。
  一个进程中的多个线程既共享这个进程的资源，同事又有自己的私有资源。
创建进程：
    使用os模块创建进程：
      pid = os.fork():创建一个父子进程　不用参数
      pid = -1创建失败
      当创建成功(两个返回值)　创建一个子进程(复制全部父进程的代码)　并返回父进程的id　同时运行(子进程os.fork()下一句开始运行)　返回子进程的pid号(0)
      os.getpid():打印当前id号
    subprocess模块：提供了一种一致的方法来创建和处理附加进程。
      subprocess.call(['命令','参数'])　执行一个命令或一个脚本

    multiprocessing:创建多个进程
    multiprocessing 模块
      Pool()函数：创建多个进程
      Pool(a):最多一起跑a个进程

僵尸进程（占内存　要处理）：
    当父子进程一起运行时，父进程结束了　而没有收到子进程的状态信息　那么就成为僵尸进程
    一个进程创建子进程，如果子进程退出，而父进程并没有获取子进程状态信息，那么子进程的进程描述仍然
    保留在系统中。这种进程称之为僵尸进程。僵尸进程会浪费一定的系统资源。
  如何避免僵尸进程：
    os.wait()：阻塞等待(放在父进程中)　直到子进程执行完　捕获子进程给父进程的消息　返回一个元祖
                元祖中包括子进程结束给父进程的信息等
    os.waitpid(-1，os.WNOHANG):阻塞等待　
                  第一个参数：-1:表示父进程中的任意一个子进程退出都捕捉到　
                            0:表示这个进程组中任意一子进程退出捕捉到　
                            >0:表示指定进程号　只有这个进程号退出捕捉到
                  第二个参数：(可有可无)WNOHANG：判断子进程是否退出，如果退出则进行处理，如果没有退出，则不进行阻塞
    os.exit():进程的退出状态
    信号处理僵尸进程大方法：
孤儿进程(不用处理)：
    子进程没有结束，父进程先结束

进程线程的通信：
    进程间的通信就是在不同进程之间传播或交换信息
    进程间通信（ipc）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同事运行，并相互传递，交换信息。
  信号：信号是一个操作系统的特性，他提供了一个路径可以通知进程发生了一个事件并异步处理这个事件。信号可以由系统本身生成，也可以从
        一个进程发送到另一个进程。
        信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。
        信号可以直接进行用户空间进程和内核进程之间的交互，内核进程因为可以利用它来通知用户控件进程发生了哪些系统事件。
        如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；
        如果一个信号被进程设置称为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才传递给进程
  linux下常见信号：
        信号名　　　　　　　　含义　　　　　　　　　　　　　　　　　　　　　　　默认操作
        SIGHUP     该信号在用户终端连接(正常或非正常)结束时发出，　 　　　　　终止
                    通常是在终端的控制进程结束时，通知通知同一会
                    话内的各个作业与控制终端不再关联。
        SIGINT     该信号在用户键入INIT字符（通常是Ctrl-C）时发出，　　　　　终止　　
                    终端驱动程序发送此信号并送到前台进程中的每一个进程
        SIGQUIT     该信号和SIGINT类似，但由QUIT字符（通常是Ctrl-\　　　　　终止
                    来控制                             　         　
        SIGILL     该信号在一个进程企图执行一条非法指令时(可执行文件本身　　　　终止
                    出现错误，或者试图执行数据段、堆栈溢出时)发出　　　　　　　
        SIGRPE　　　该信号在发生致命的算数运算错误时发出。这里不仅包括浮点　　　　终止
                    运算符错误，还包括溢出及除数为零等其他所有的算术错误。
        SIGKILL　　　该信号用来立即结束进程的运行，并且不能被阻塞、处理和忽略　　　终止
        SIGALRM     该信号当一个定时器时间到时发出　　　　　　　　　　　　　　　　终止
        SIGSTOP     该信号用于暂停一个进程，且不能被阻塞、处理或忽略　　　　　　暂停进程
        SIGTSTP     该信号用于暂停交互进程，用户可键入SUSP字符（通常
                      是Ctrl-Z）发出这个信号　　　　　　　　　　　　　　　　　　暂停进程
        SIGCHLD　　　子进程改变状态时，父进程会收到这个信号　　　　　　　　　　　忽略
        SIGABORT    该信号用于结束进程　　　　　　　　　　　　　　　　　　　　　 终止　　
                      　　　
    os模块：kill()
    signal模块(包含几乎所有的信号)：异步处理方式
    os.kill(pid,signal.SIGKILL) 终止pid号的进程
    signal.alarm(a) 该信号当一个定时器当时a秒之后发送一个(SIGALARM)信号　终止进程
                    下一个alarm()会覆盖上一个alarm
                    如果没有上一个时钟　返回一个零
                    如果有上一个时钟　返回上一个时钟的剩余时间
    signal.pause() 阻塞函数　当有任何一个信号传递给这个进程　终止阻塞

    信号的处理：
              １．忽略信号
              ２．采用默认方式处理　默认处理方式：终止进程，暂停进程，忽略
              ３，采用指定函数处理

    signal.signal()：信号处理函数
           signal.signal(SIGALAM,SIG_DFL)：采用默认方式处理　
                        第一个参数是：需要处理的信号名称
                        第二个参数是：处理方式
           signal.signal(SIGINT,SIG_IGN):忽略信号
           signal.signal()(代码：signum.py)
向进程中传递消息
    python中进程见消息传递的方式常用的有Queue、Pipe和Socket的方法
    利用multiprocess完成进程间通信的一种简单方式　利用一个Queue来回传递消息。
    无名管道pipe：(代码：无名管道.py)：
        (r,w) = os.pipe()一个作为固定的输入端，一个作为固定的输出端
        r.send():向管道输入一些字符
        w.recv()：从管道输出一些字符
    消息队列：queue(代码：消息队列.py)
    q = Queue()
        q.put()　向队列一端中加入一个值
        q.get()[0] 在队列另一端输出第一个值
        q.full()　判断队列是否为满
        q.empty() 判断队列是否为空
        q.qsize()　判断队列的大小

进程间的同步与互斥：
    进程同步是一个操作系统级别的概念，是在多道程序的环境下，存在着不同的制约关系，为了协调这个制约互相制约的关系，实现资源共享
    和进程协作，从而避免进程之间的冲突，进入了进程同步
临界资源：
    在操作系统中，进程是占有资源的最小单位(线程可以访问其所在进程内的所有资源，但线程本省并不占有资源后仅仅占有一点必须的资源)。
    但对于某些资源来说，其在同一时间内只能被一个进程所占用。这些一个只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源
    比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能
    造成丢数据的问题)。对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所
    申请的临界资源被释放。而进程内访问临界资源的代码被称为临界区。

    对于临界区的访问过程分为四个部分：
    1.进入区：查看临界区是否可被访问，如果可以访问，则转到步骤二，否则进程会被阻塞
    2.临界区：在临界区做操作
    3.退出区：清除临界区被占用的标志
    4.剩余区：进程与临界区不相关的代码
进程同步：
    进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某个位置上协调他们的工作次序而等待
    、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作
进程互斥
    进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，
    这个进程才会接触阻塞状态。
事件：Event类提供了一种简单的方法，可以在进程之间传递状态信息。时间可以切换设置和未设置的状态。通过一个可选的超时值，时间对象的用户
    可以等待其状态从未设置变为设置。
    通过multiprocessing模块中的Event()
    e = multiprocessing.Event()实例化一个事件对象
    e.set()设置一个事件
    e.clear()清除已被设置的事件
    e.is_et()判断事件是否被设施
锁：如果需要在多个进程下共享一个资源，可以用Lock来避免访问冲突
    通过multiprocessing模块中Lock()设定锁
    lock = multicessing.Lock()实例化一个锁对象
    with lock:       :设置锁　只有执行完它下面的代码才可以执行别的 执行完自动解锁
    lock.acquite()   :设置锁　　lock.release()   :解锁


多线程编程
    线程的问题:1.存在线程安全问题，出现了问题不易定位。２．进程内部有线程数目的限制。随着并发量的增加，线程生产和切换的成本也变得昂贵，散落在多个地方
    对开发和卫华非常不利。
    threading.currenThread() 返回当前线程列表
    threading.enumerate() 返回当前活动线程列表
thrading模块对象　　　　　　　　　　　描述
Thread                           表示一个进程的执行的对象
Lock                             锁原语对象(跟thread模块里的锁对象相同)
RLock                            可重新入锁对象。使单线程可以再次获得已经获得了的锁(递归锁定)
Condition                        条件变量对象能让一个线程停下来，等待其他线程满足了某个“条件”.如，状态的改变或值的改变
Event                            通用的条件变量。多个线程可以等待某个事件的发生，在事件发生后，所有的线程都被激活。
Semaphore                        为等待锁的线程提供一个类似'等候室'的结构
BoundedSemaphore 与　Semaphore类似，只是他不允许超过初始值
Timer 与 Thread　相似，只是，他要等待一段事件后才可以运行。

信号的传递：
    事件：
    尽管使用多线程的目的是并发的运行单个操作，不过有时也需要在两个或多个线程中同步操作。事件对象是实现线程间安全通信的一种简单方法。
    Event管理一个内部标志，调用者可以用set()和clear()方法控制这个标志。其他线程可以使用wait()暂停，直到设置这个标志，其效果就是
    在允许继续之前阻塞线路的运行。
线程锁：
    lock = threading.Lock() 实例化一个锁对象
    lock.acquore()　上锁
    lock.releadse　解锁

生产者消费者模式:
  生产者就是产生数据的线程，消费者就是消耗数据的线程。
  如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产。
  同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待消费者。

协程：
  协程简单描述：
      协程的生成成本更低。其实就是一块内存，记录之前的调用的栈的信息。甚至可以通过控制函数调用的层次来进一步降低协程的大小，
      。要生成一个协程，只需要申请一块内存并赋值。
      切换更快。基本就是内存的拷贝速度。
      没有线程安全问题。一个进程可以同时存在多个协程，但是只有一个协程是激活的，而且协程的激活和鞋面时程序员通过编程来控制，而不是
      内核来控制。这样就没有了线程安全问题。
      可读性更好。相对ＩＯ多路复用来说，你调动的服务接口或者ＩＯ接口是异步的，但是你的代码是流畅的，并没有被异步和回调打乱。协程也是异步的，
      但是它会把异步的事件和回调封装起来，形成类似远程调用接口。
    协程可以用来做什么？
      １.逻辑描述：我主要把协程用来描述逻辑。一个流程可能需要调用多个接口，其中很多接口是异步的。用线程可以解决部分问题，但是复杂度提升。
      ２.提高并发：主要应用于在io密集型应用中。
    协程的缺陷：
      无法使用多核，可以通过进程＋协程来解决。

网络编程：
  OSI模型：开放系统互联参考模型是国际化标准组织iso和国际电报电话咨询委员会ccitt联合指定的开放系统互连参考模型，为开放式互联信息提供了一种功能结构框架，
  分为7层:物理层、数据链路层、网络层、传输层、表示层、应用层。通常把1~4层协议称为下层协议，5~7层称为上层协议。
      １．物理层：以二进制数据形式在物理媒体上传输数据　　　ISO2110,IEEE802.1 EEE802.2
      ２．链路层：传输有地址的帧以及错误检测功能          SLIP,CSLIP,PPP,ARP,RARP,MTU
      ３．网络层：为数据包选择路由                      IP,ICMP,RIP,OSPF,BFP,IGMP
      ４．传输层：提供端对端的接口                     　TCP,UDP
      ５．会话层：解除或建立与别的节点的联系
      ６．表示层：数据格式化，代码转换，数据加密
      ７．应用层：文件传输，电子邮件，文件服务，虚拟终端    TFTP,HTTP,SNMP,FTP,SMTP,DNS,Tnlnet
   又可以分为4层：
        应用层：　Telnet、FTP、HTTP、DNS、SMTP等(应用层，表示层，会话层)
        传输层：TCP和UDP
        网络层：IP、ICMP、IGMP
        网络接口和物理层：以太网、令牌环网、FDDI等(物理层和数据链层)
    协议：
    网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，
    计算机之间才能互相通信交流。它的三要素；语法、语义、时序。
    缺少协议部分；










socket套接字：
  需要查的内容（子网掩码　dns地址　网关　广播地址　什么是０．０．０．０　网卡地址）
  在linux系统下socket还是一种特殊的文件描述符。通过socket形成的网络通信并不仅限于tcp/ip协议。普通的i/o操作是打开文件
  ，读写操作，关闭文件，而通过socket tcp/ip协议被集成了操作系统的内核中，引入了新型i/o操作。
socket套接字分为以下几种：
  流式套接字(SCOK_STREAM)
    提供了一个面向连接、可靠的数据传输服务，数据无差错、无重复的发送且按发送顺序接收。内置流量控制，避免数据淹没慢的接收方。
    数据被看作是字节流，无长度限制。
  数据报套接字(SOCK_DGRAM)
    提供无连接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。
  原始套接字(SOCK_TAW)
    可以对较低层协议如IP、ICMP直接访问。
主机：
    print socket.gethostname()　　获取当前用户名名
    print socket.gethostbyname('域名')　通过域名获得ip地址
ip地址：
    ip地址是internet中主机的表示，internet中的主机要与别的机器通信必须具有一个ip地址
    ip地址为32位(ipv4)或者128位(ipv6)。每个数据包都必须携带目的ip地址和源ip地址，路由器依靠此信息为数据包选择路由。在表示形式常用
    点分形式，如192.168.1.2,最后都会转换为一个32位的无符号整数。
    hostname,aliases,address = socket.gethostbyaddr('ip')　　获取主机名　别名 和　ip
端口号：
    为了区分一台主机接收的数据包应该交给哪个进程来处理，使用端口号来区别。
    tcp端口号与udp端口号独立
    端口号一般由IANA(internet Assigned Numbers Authority)管理中所周知端口：１～1023(1~255之间为众所周知端口，256~1023端口通常由
    UNIX系统占用)已登记端口：1024~49151动态或私有端口:49152~65535
    import socket
    from urlparse import urlparse
    parsed_url = urlparse('域名')
    port = socket.getservbyname(parsed_url.scheme)  得到端口号
字节序：
    不同类型CPU的主机中，内存存储多字节整数序列有两种方法，称为主机字节序(HBO):
      小端序：低序字节存储在低地址
        将低字节存储在起始地址，称为'Little-Endian'字节序,intel、AMD等曹勇的是这种方式；
      大端序：高序字节存储在低地址
        将高字节存储在起始地址，称为‘Big-Endian’字节序，由AMD、Motorola等所采用
    利用inet_aton()和inet_ntoa等函数实现ip地址和网络字节的转换，利用htons和ntohs实现端口数字和网络字节的转换
    packed = socket.inet_aton('192.168.1.131') 将ip数字地址转化为网络字节
    print socket.inet_noto(packed) 将网络字节转化为数据ip地址
    port = socket.htons(8888)  将整型变量从主机字节顺序转变成网络字节顺序
    print socket.ntohs(post) 　将网络字节顺序转换为主机字节顺序
TCP网络通信：
    TCP(即传输控制协议)：是一种面向连接的传输层协议，他能提高可靠性通信(即数据无误、数据无丢失、数据无失序、数据无重复到达的通信)
    适用情况：适合于对传输质量要求较高，以及传输大量数据的通信。在需要可靠数据传输的场合，通常使用tcp协议msn/qq等及时通讯软件的用户
            登录账号管理相关的功能通常采用tcp协议。
    tcp连接建立要经过三次握手　断开要经过四次挥手
创建tcp套接字：
    import socket
    tcpSock = socket.socket(AF_INET,SOCK_STREAM,protocol = 0)　　创建一个tcp套接字
    tcpSock = socket.socket()　什么参数都不传也是创建一个tcp套接字
    第一个参数：socket_family:
    AF_INET:通信方式　ipv4　AF_INET6:通信方式　ipv6：这两个为网络套接字通用
    AF_UNIX:本地通信
    第二个参数：决定创建的套接字类型
    SOCK_DGRAM:　数据报式　UDP
    SOCK_STREAM：流式　　TCP协议
套接字对象的方法：
    s = socket.scoket()
    服务器端套接字函数：
      s.bin()     绑定地址(主机，端口号(必须是一个整数))　到套接字　UDP服务器只要这个 (必须是一个数组)
      s.listen()　开始tcp监听 (tcp)
      s.accept()  被动接收tcp客户的链接,(阻塞式)等待连接的到来(tcp)
    客户端套接字函数:
      s.connect() 向服务端发送连接请求 (tcp)
    公共用途：
      s.recv() 接收tcp数据
      s.send() 发送tcp数据
      s.sendall() 完成发送udp数据
      s.recvfrom() 接收udp数据　需要(数据，接收方的ip和端口号)
      s.sendto()   发送udp数据　需要(数据，接收方的ip和端口号)
      s.getpeername() 连接到当前套接字远端的地址
      s.getsockname() 当前套接字的地址
      s.getsockopy() 返回指定套接字的参数
      s.setsocketopt() 设置指定套接字的参数
      s.close() 关闭套接字





    s.setsockopt(level,optname,value)： 默认的socket选项不够用的时候，就必须要使用setsockopt来调整。就是使用setsockopt。
                第一个参数level:选项定义的层次：支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。
                第二个参数optname:需要设置的选项：知道的有socket.SO_PEUSEADDR：重用本地端口　socket.SO_BROADCAST:支持广播
                第三个从参数value：设置选项值

    第三个参数：
    和套接字　一般为0
    返回值为：返回要使用的套接字

    套接字使用的方法：

UDP网络通信：
    n = sockf.sendto(data,ADDR):发送　第一个参数，要传送的数据　第二个参数：地址
    data,addr = sockfd.recvfrom(BUFSIZE)

超时检测：(代码：超时检测.py)
    在网络通信中，很多操作会使进程阻塞。python2.3为socket引入了一个新的特性:超时(timeouts).超时在很多情况下对发现错误或链接问题很有用。
    超时检测的必要性就在于避免进程在没有数据时无线的阻塞，当设定的时间到时，进程从源操作返回继续操作。在读取数据的时候，超时可以用于强迫断开
    不后动的客户端。无论是读还是写数据，您都可以用来超时来检查断掉的链接。
超时检测方法：
    为了使Python的socket具有超时检查功能，你需要调用socket的settimeout()函数，向传递给它的函数表明，经过多少秒算超时。稍后访问一个socket
    ，如果经过了参数设定的时间后，什么都没发生，则会产生一个socket.timeout异常。

广播和组播(广播代码：发送广播和接收广播：组播代码：)
    广播数据：数据包发送方式只有一个接收方，称为单播
            如果同时发给局域网中所有的主机，称为广播
            多数用UDP实现的，当你广播一个udp信息包的时候，他会发送到连接在局域网上的所有的机器。
    广播地址
      以192.168.1.0(255.255.255.0)网段为例，最大的主机地址192.168.1.255代表该网段的广播地址发送到该地址的数据包被所有的主机接收
      255.255.255.255在所有网段中都代表广播地址。
      当socket既发送也接收广播的时候，必须首先强调s.setsocketopt(socekt.SOL_SOCKET,socket.SO_BROADCAST,1)来使socket支持广播
      。要发送一个广播,也可以用特殊的地址'broadcast',而不是标准的ip地址和主机名

      在广播中，有两方面的工作要做：发送方和接收方。

    组播：
      单播方式只能发给一个接收方。广播方式发送给所有的主机。过多的广播会大量占用网络宽带，造成广播风暴，影响正常通信。组播(又称多播)是一种
      折中的方式。只有加入某个多播组的主机才能收到数据。组播方式既可以发送给多个主机，又能避免向广播那样带来过多的负载(每台主句要到传输层
      才能判断广播包是否要处理)。组播消息总是使用UDP发送，因为TCP需要一个端对端的通道。
    地址分类
      A类地址
      第一字节为网络地址，其他３个字节为主机地址。第一字节的最高位固定为0
      1.0.0.1-126.255.255.255
      B类地址
      第一字节和第二自己个字节是网络地址，其他两个字节是主机地址，第一个字节的前两位固定是10
      128.0.0.1-191.255.255.255
      C类地址
      前三个字节都是网络地址，最后一个字节是主机地址。第一字节的前三位固定为110
      192.0.0.1-223.255255255
      D类地址（组播地址）
      不分网络地址和主机地址，第一字节的前四位固定为1110
      224.0.0.1-239.255.255.255
UNIX本地套接字
    socket同样可以用于本地通信，而且和其他进程通信方式相比使用方便、效率更高。使用UNIX套接字和TCP/IP套接字存在根本区别。首先，
    套接字存在两个根本区别。首先，套接字的地址是文件系统上的一个路径，而不是一个包含服务器名和端口号的元祖。其次，文件中创建的表示套接字的节点会持续保存
    ，即使套接字关闭也仍然存在，所以每次服务器启动时都需要将其删除。

python的web编程：
    统一资源定位符(URL)
      统一资源定位符是对可以从互联网上得到资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的，每一个文件都有唯一的ULR,
      它包含的信息指出文件的位置以及浏览器应该怎么处理它。
    urllib vs urllib2
      虽然python的模块urllib和urllib2都提供了同样的基本功能，但是urllib2扩展性更好，并且有更多的内置特性.虽然python2中urllib2的使用比较被推崇
      ，但是在python３中的新版本中对urllib模块进行了一定的改版，删除了urllib2模块。在这里对这两个模块分别做下介绍。
        urllib模块提供几乎所有你需要的功能。
        rullib.urlopen()
        urlopen()打开一个给定URL字符串与Web连接，并返回文件类的对象。语法结构如下：
            urlopen(urlstr,postQueryData=None)

做一个简单的爬虫：
安装mysql
